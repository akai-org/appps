---
import LanguageFilter from "./filters/LanguageFilter.astro";
import SearchFilter from "./filters/SearchFilter.astro";
import Sort from "./filters/Sort.astro";
const { languages } = Astro.props;
---

<script>
  type Project = {
    project: Element;
    title: string;
    languages?: string[] | undefined;
    starCount?: number;
    updateDate?: number;
  };

  class UrlHandler {
    params: URLSearchParams;
    filterHandler: FilterHandler;
    constructor(filterHandler: FilterHandler) {
      this.params = new URLSearchParams(window.location.search);
      this.filterHandler = filterHandler;
      this.setupListeners();
    }
    hasSearch(): boolean {
      return this.params.get("search") !== "";
    }
    hasLangs(): boolean {
      return this.params.has("language");
    }
    applyFilters() {
      if (this.hasSearch()) {
        const input: HTMLInputElement = document.querySelector(`#search`)!;
        input.value = this.params.get("search")!;
      }
      if (this.hasLangs()) {
        for (const language of this.params.getAll("language")) {
          const inputId = `lang-${language.toLowerCase()}`;
          const input: HTMLInputElement = document.querySelector(
            `#${inputId}`,
          )!;
          input.checked = true;
        }
      }
      const data = new FilterData(this.params as any);
      this.filterHandler.filter(data);
      const countChangeEvent = new CustomEvent("count_change", {
        bubbles: true,
      });
      document.dispatchEvent(countChangeEvent);
    }
    setupListeners() {
      document.addEventListener("url_change", (e) => {
        this.changeState(e);
      });
      window.addEventListener("DOMContentLoaded", (_) => {
        this.applyFilters();
      });
    }
    changeState(event: any) {
      this.params = new URLSearchParams(event.detail.data);
      window.history.replaceState(
        {},
        "",
        `${location.pathname}?${this.params.toString()}`,
      );
    }
  }
  class SortData {
    sortType: string;
    sortOrder: string;
    constructor(data: FormData) {
      const dataSplitted = data.get("sort")?.toString().split("_")!;
      this.sortType = dataSplitted[0];
      this.sortOrder = dataSplitted[1];
    }
  }

  class SortHandler {
    projectsCont: Project[][]; // Array of arrays because we are sorting separately projects which are grouped in two different containers
    containerEls: Element[];
    constructor() {
      this.projectsCont = [[], []];
      this.containerEls = [...document.getElementsByClassName("projects_cont")];
      for (const [idx, cont] of this.containerEls.entries()) {
        const projects = [...cont.querySelectorAll(".project")];
        for (const projectEl of projects) {
          const project: Project = {
            project: projectEl,
            title: projectEl
              .getAttribute("data-title")
              ?.toLowerCase() as string,
            starCount: parseInt(projectEl.getAttribute("data-stars")!),
            updateDate: new Date(
              projectEl.getAttribute("data-updateDate")!,
            ).getTime(),
          };
          this.projectsCont[idx].push(project);
        }
      }
      this.sort({ sortType: "alpha", sortOrder: "ascend" });
    }
    sort(sortData: SortData) {
      const isDescending = sortData.sortOrder === "descend";
      let sortFunction: (a: Project, b: Project) => number;
      switch (sortData.sortType) {
        case "alpha":
          sortFunction = this.sortAlpha;
          break;
        case "star":
          sortFunction = this.sortStars;
          break;
        case "date":
          sortFunction = this.sortDate;
          break;
      }
      this.projectsCont.forEach((container) => {
        container.sort(sortFunction);
        if (isDescending) container.reverse();
      });
      this.applySort();
    }
    applySort() {
      for (const [idx, cont] of this.containerEls.entries()) {
        for (const project of this.projectsCont[idx]) {
          cont.appendChild(project.project);
        }
      }
    }
    sortAlpha(a: Project, b: Project): number {
      if (a.title === b.title) return 0;
      return a.title > b.title ? 1 : -1;
    }
    sortStars(a: Project, b: Project): number {
      if (a.starCount === b.starCount) return 0;
      return a.starCount! > b.starCount! ? 1 : -1;
    }
    sortDate(a: Project, b: Project): number {
      if (a.updateDate === b.updateDate) return 0;
      return a.updateDate! > b.updateDate! ? 1 : -1;
    }
  }

  class FilterData {
    search: string;
    languages: string[];
    constructor(data: FormData) {
      this.search = data.get("search") as string;
      this.languages = data.getAll("language") as string[];
    }
  }
  class FilterHandler {
    projectClass: string;
    projects: Project[];
    filterData: FilterData;
    hiddenProjects: Element[];

    constructor(containerClass: string) {
      this.projectClass = containerClass;
      this.projects = [...document.getElementsByClassName(containerClass)].map(
        (project) => {
          return {
            project: project,
            title: project.getAttribute("data-title")?.toLowerCase() as string,
            languages: project.getAttribute("data-langs")?.split(","),
          };
        },
      );
      this.filterData = new FilterData(new FormData());
      this.hiddenProjects = [];
    }
    clearFilters() {
      for (const project of this.hiddenProjects) {
        this.toggleVisibility(project, true);
      }
      this.hiddenProjects = [];
    }
    filter(filterData: FilterData) {
      this.filterData = filterData;
      this.hiddenProjects = [];
      for (const project of this.projects) {
        const projectTitle = project.title;
        const projectLangs = project.languages;

        const hasTitle = this.hasTitle(projectTitle);
        const hasLang = this.hasLangs(projectLangs);

        if (!hasLang) {
          this.toggleVisibility(project.project, false);
          this.hiddenProjects.push(project.project);
        }
        if (!hasTitle) {
          this.toggleVisibility(project.project, false);
          this.hiddenProjects.push(project.project);
        }
        if (hasTitle && hasLang) {
          this.toggleVisibility(project.project, true);
        }
      }
    }
    toggleVisibility(project: Element, visible: boolean) {
      if (visible) {
        project.classList.remove("hidden");
      } else {
        project.classList.add("hidden");
      }
    }
    hasTitle(projectTitle: string) {
      const search = this.filterData.search;
      return search ? projectTitle?.indexOf(search) !== -1 : true;
    }
    hasLangs(projectLangs: string[] | undefined) {
      const langs = this.filterData.languages;
      return langs.length !== 0 || !langs
        ? projectLangs?.some((lang) => langs.includes(lang!))
        : true;
    }
  }

  class FormHandler {
    filterForm: HTMLFormElement;
    sortForm: HTMLFormElement;
    constructor(filterFormId: string, sortFormId: string) {
      this.filterForm = document.getElementById(
        filterFormId,
      ) as HTMLFormElement;
      this.sortForm = document.getElementById(sortFormId) as HTMLFormElement;
      this.setupListeners();
    }
    setupListeners() {
      const sortHandler = new SortHandler();
      this.sortForm.addEventListener("change", (_) => {
        const formData = new FormData(this.sortForm);
        const sortData = new SortData(formData);

        sortHandler.sort(sortData);
      });

      const filterHandler = new FilterHandler("project");
      this.filterForm.addEventListener("submit", (e) => {
        e.preventDefault();
      });
      this.filterForm.addEventListener("input", (e) => {
        const formData = new FormData(this.filterForm);
        const filterData = new FilterData(formData);

        filterHandler.filter(filterData);

        const urlChangeEvent = new CustomEvent("url_change", {
          bubbles: true,
          detail: { data: formData },
        });
        e.target?.dispatchEvent(urlChangeEvent);

        const countChangeEvent = new CustomEvent("count_change", {
          bubbles: true,
        });
        e.target?.dispatchEvent(countChangeEvent);
      });
      this.filterForm.addEventListener("reset", filterHandler.clearFilters);

      const urlHandler = new UrlHandler(filterHandler);
    }
  }
  const formHandler = new FormHandler("formFilter", "formSort");
</script>
<div id="form" class="grid gap-y-3 text-black accent-yellow-500">
  <form id="formSort">
    <Sort />
  </form>
  <form id="formFilter" class="grid gap-y-3">
    <SearchFilter />
    <LanguageFilter languages={languages} />
    <input
      type="reset"
      value="Wyczyść"
      class="w-fit rounded-lg bg-amber-400 px-3 py-2 font-bold text-white hover:cursor-pointer"
    />
  </form>
</div>
